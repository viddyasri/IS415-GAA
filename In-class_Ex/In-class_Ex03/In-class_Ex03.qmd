---
title: "KDE & NKDE"
execute: 
  warning: false
date: "`r Sys.Date()`"
format:
  html:
    code-fold: false
    code-tools: false
    code-summary: "Show code"
highlight-style: dracula
---

# Kernel Density Estimation

## **1. Getting Started**

#### Installing relevant packages

```{r}
#| eval: false
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap, tidyverse)
```

## **2. Spatial Data Wrangling**

#### Importing the spatial data

```{r}
childcare_sf <- st_read("../../Hands-on_Ex/Hands-on_Ex03/data/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
mpsz_sf <- st_read(dsn = "../../Hands-on_Ex/Hands-on_Ex03/data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

#### Creating the coastal outline

```{r}
#get the outline by dissolving the boundaries, merge everything
#use st_union to make sure you only have one polygon
sg_sf <- mpsz_sf %>%
  st_union() 
```

```{r}
plot(sg_sf)
```

## **3. Geospatial Data Wrangling**

#### Creating ppp objects: sf method

```{r}
#ppp objects can be used with spatstat
childcare_ppp <- as.ppp(childcare_sf)
```

```{r}
summary(childcare_ppp)
```

```{r}
plot(childcare_ppp)
```

#### Handling duplication

```{r}
any(duplicated(childcare_ppp))
```

```{r}
#jitter
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

#### Create owin object

```{r}
#owin is to specify the area which we want to analyse, to be used with spatstat
sg_owin <- as.owin(sg_sf)
```

```{r}
summary(sg_owin)
```

#### Combining point events object and owin object

```{r}
childcareSG_ppp <- childcare_ppp[sg_owin]
```

## **4. Comparing Spatial Point Patterns using KDE**

#### Extracting Target Plan Areas

```{r}
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

#### Plotting target planning areas

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Punggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

# Network Constrained Kernel Density Estimation

## **1. Getting Started**

#### Installing relevant packages

```{r}
pacman::p_load(sf, spNetwork, tmap, classInt, viridis, tidyverse)
```

## **2. Data Import and Preparation**

```{r}
network <- st_read(dsn="data/geospatial", 
                   layer="Punggol_St")
```

```{r}
childcare <- st_read(dsn="data/geospatial",
                     layer="Punggol_CC")
```

Print the content of network SpatialLineDataFrame and childcare SpatialPointsDataFrame by using the code below:

```{r}
str(network)
str(childcare)
```

## **3. Visualising the Geospatial Data**

```{r}
tmap_mode('plot')
tm_shape(childcare) + 
  tm_dots() + 
  tm_shape(network) +
  tm_lines()
#tmap_mode('plot')
```

## **4. Network Constrained KDE (NetKDE) Analysis**

#### Preparing the lixels objects

```{r}
lixels <- lixelize_lines(network, 
                         750, 
                         mindist = 375) #mindist is half of 750 (mid distance)
```

The length of a lixel, lx_length is set to 750m, and The minimum length of a lixel, mindist is set to 375m.

#### Generating line centre points

```{r}
samples <- lines_center(lixels)
```

The points are located at center of the line based on the length of the line.

#### Performing NetKDE

```{r}
densities <- nkde(network, 
                  events = childcare,
                  w = rep(1,nrow(childcare)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, 
                  div= "bw", 
                  method = "simple", 
                  digits = 1, 
                  tol = 1,
                  grid_shape = c(1,1), 
                  max_depth = 8,
                  agg = 5, #we aggregate events within a 5m radius (faster calculation)
                  sparse = TRUE,
                  verbose = FALSE)
```

#### Visualising NetKDE

```{r}
#insert the computed density values (i.e. densities) into samples and lixels objects as density field.
samples$density <- densities
lixels$density <- densities
```

```{r}
# rescaling to help the mapping
samples$density <- samples$density*1000
lixels$density <- lixels$density*1000
```

```{r}
tmap_mode('plot')
tm_shape(lixels)+
  tm_lines(col="density")+
tm_shape(childcare)+
  tm_dots()
```
