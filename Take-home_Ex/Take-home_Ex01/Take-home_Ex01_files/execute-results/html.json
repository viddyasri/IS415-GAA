{
  "hash": "a76f3de8fc8ecdc44e72784e238c2033",
  "result": {
    "markdown": "---\ntitle: \"Take-home Exercise 1: Application of Spatial Point Patterns Analysis to discover the geographical distribution of Grab hailing services in Singapore\"\nexecute: \n  warning: false\ndate: \"2024-01-27\"\nhighlight-style: dracula\n---\n\n\n## **1. Overview**\n\nHuman mobility, defined as the movement of persons through space and time, provides important insights into the spatial and temporal elements of human activity.\n\nThis study intends to use appropriate spatial point pattern analysis methods to reveal the geographical and spatiotemporal distribution of Grab hailing service locations in Singapore. This would further improve our understanding of how Grab services are spatially dispersed and evolve over time, providing useful insights for informed decision-making in the field of smart city planning.\n\n## **2. The Data**\n\nThis study will utilize three datasets, namely:\n\n-   Grab-Posisi data for Singapore\n\n-   Road dataset sourced from OpenStreetMap\n\n-   Master Plan 2019 Subzone Boundary (Excluding Sea) from Data.gov.sg.\n\n## **3. Installation and Loading of Packages**\n\nThe R packages that will be used in this study are:\n\n-   **sf:** for importing, managing, and processing geospatial data\n\n-   **tidyverse:** for performing data science tasks\n\n-   **tmap:** for plotting cartographic quality static point patterns maps or interactive maps by using leaflet API\n\n-   **raster:** reads, writes, manipulates, analyses and model of gridded spatial data\n\n-   **spatstat:** has a wide range of useful functions for point pattern analysis\n\n-   **maptools:** for manipulating geographic data\n\n-   **spNetwork:** for performing spatial analysis on networks\n\n-   **classInt:** for choosing univariate class intervals for mapping or other graphics purposes.\n\n-   **viridis:** for generating the color maps in base R\n\n-   **arrow:** for a wide range of data analysis tasks\n\n-   **lubridate:** provides functions for working with dates and times\n\n-   **dplyr:** for wrangling data\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"maptools\", repos = \"https://packagemanager.posit.co/cran/2023-10-13\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tidyverse, tmap, raster, spatstat, maptools, spNetwork, classInt, viridis, arrow, lubridate, dplyr)\n```\n:::\n\n\n## **4. Import Data**\n\n### 4.1 Grab-Posisi data\n\nThe ***read_parquet()*** function is associated with the ***arrow*** package in R. This function is used to read data from a Parquet file. However, it is important to note that the current data is aspatial and is not in the sf tibble data frame format. The data will be converted at a later stage in this study.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- read_parquet(\"../../data/GrabPosisi/part-00000.parquet\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 3,034,553\nColumns: 9\n$ trj_id        <chr> \"70014\", \"73573\", \"75567\", \"1410\", \"4354\", \"32630\", \"646…\n$ driving_mode  <chr> \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", …\n$ osname        <chr> \"android\", \"android\", \"android\", \"android\", \"android\", \"…\n$ pingtimestamp <int> 1554943236, 1555582623, 1555141026, 1555731693, 15555844…\n$ rawlat        <dbl> 1.342326, 1.321781, 1.327088, 1.262482, 1.283799, 1.3003…\n$ rawlng        <dbl> 103.8890, 103.8564, 103.8613, 103.8238, 103.8072, 103.90…\n$ speed         <dbl> 18.910000, 17.719076, 14.021548, 13.026521, 14.812943, 2…\n$ bearing       <int> 248, 44, 34, 181, 93, 73, 82, 321, 324, 31, 203, 50, 252…\n$ accuracy      <dbl> 3.900, 4.000, 3.900, 4.000, 3.900, 3.900, 3.000, 3.649, …\n```\n:::\n:::\n\n\n### 4.2 Road dataset\n\nThe ***st_read()*** function is associated with the ***sf*** package in R. This function is used to read spatial data from various formats. When using the st_read function to read a shapefile, there is no need to explicitly specify the file format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroad_sf <- st_read(dsn = \"../../data\", \n                layer = \"gis_osm_roads_free_1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `gis_osm_roads_free_1' from data source \n  `C:\\viddyasri\\IS415-GAA\\data' using driver `ESRI Shapefile'\nSimple feature collection with 1764332 features and 10 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 99.66041 ymin: 0.8021131 xmax: 119.2601 ymax: 7.514393\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(road_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,764,332\nColumns: 11\n$ osm_id   <chr> \"4386520\", \"4578273\", \"4579495\", \"4579533\", \"4579534\", \"45795…\n$ code     <int> 5113, 5114, 5122, 5122, 5122, 5122, 5141, 5122, 5122, 5122, 5…\n$ fclass   <chr> \"primary\", \"secondary\", \"residential\", \"residential\", \"reside…\n$ name     <chr> \"Orchard Road\", \"Jalan Bukit Bintang\", \"Jalan Nagasari\", \"Per…\n$ ref      <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ oneway   <chr> \"F\", \"F\", \"B\", \"B\", \"B\", \"F\", \"F\", \"F\", \"F\", \"F\", \"B\", \"B\", \"…\n$ maxspeed <int> 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 0, 0,…\n$ layer    <dbl> 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …\n$ bridge   <chr> \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"…\n$ tunnel   <chr> \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"T\", \"F\", \"F\", \"F\", \"F\", \"F\", \"…\n$ geometry <LINESTRING [°]> LINESTRING (103.8301 1.3060..., LINESTRING (101.72…\n```\n:::\n:::\n\n\n### 4.3 Master Plan 2019 Subzone Boundary (Excluding Sea)\n\nWhen using the st_read function to read a file that is not shapefile, it is necessary to explicitly specify the file format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_read(dsn = \"../../data\", \n                layer = \"MPSZ-2019\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MPSZ-2019' from data source `C:\\viddyasri\\IS415-GAA\\data' using driver `ESRI Shapefile'\nSimple feature collection with 332 features and 6 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 103.6057 ymin: 1.158699 xmax: 104.0885 ymax: 1.470775\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(mpsz_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 332\nColumns: 7\n$ SUBZONE_N  <chr> \"MARINA EAST\", \"INSTITUTION HILL\", \"ROBERTSON QUAY\", \"JURON…\n$ SUBZONE_C  <chr> \"MESZ01\", \"RVSZ05\", \"SRSZ01\", \"WISZ01\", \"MUSZ02\", \"MPSZ05\",…\n$ PLN_AREA_N <chr> \"MARINA EAST\", \"RIVER VALLEY\", \"SINGAPORE RIVER\", \"WESTERN …\n$ PLN_AREA_C <chr> \"ME\", \"RV\", \"SR\", \"WI\", \"MU\", \"MP\", \"WI\", \"WI\", \"SI\", \"SI\",…\n$ REGION_N   <chr> \"CENTRAL REGION\", \"CENTRAL REGION\", \"CENTRAL REGION\", \"WEST…\n$ REGION_C   <chr> \"CR\", \"CR\", \"CR\", \"WR\", \"CR\", \"CR\", \"WR\", \"WR\", \"CR\", \"CR\",…\n$ geometry   <MULTIPOLYGON [°]> MULTIPOLYGON (((103.8802 1...., MULTIPOLYGON (…\n```\n:::\n:::\n\n\n## **5. Converting Aspatial Data to Geospatial Data**\n\nIn this section, we will be preparing Grab taxi location points by origins and converting them into sf tibble data frames.\n\n### 5.1 Convert integer to datetime format\n\nIn the previous section, when loading the data and inspecting its structure using the glimpse function, it's clear that the pingtimestamp column is saved as an integer. Working with time-related data in raw integer format can be difficult since it lacks context.\n\nTo address this issue, the ***as_datetime()*** method from the ***lubridate*** package is used. This function is intended to convert different date and time representations, including integers, into datetime format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$pingtimestamp <- as_datetime(df$pingtimestamp)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 3,034,553\nColumns: 9\n$ trj_id        <chr> \"70014\", \"73573\", \"75567\", \"1410\", \"4354\", \"32630\", \"646…\n$ driving_mode  <chr> \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", …\n$ osname        <chr> \"android\", \"android\", \"android\", \"android\", \"android\", \"…\n$ pingtimestamp <dttm> 2019-04-11 00:40:36, 2019-04-18 10:17:03, 2019-04-13 07…\n$ rawlat        <dbl> 1.342326, 1.321781, 1.327088, 1.262482, 1.283799, 1.3003…\n$ rawlng        <dbl> 103.8890, 103.8564, 103.8613, 103.8238, 103.8072, 103.90…\n$ speed         <dbl> 18.910000, 17.719076, 14.021548, 13.026521, 14.812943, 2…\n$ bearing       <int> 248, 44, 34, 181, 93, 73, 82, 321, 324, 31, 203, 50, 252…\n$ accuracy      <dbl> 3.900, 4.000, 3.900, 4.000, 3.900, 3.900, 3.000, 3.649, …\n```\n:::\n:::\n\n\n### 5.2 Extracting location points by origin\n\nNext, to prepare the Grab taxi location points by origin, we use the code below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin_df <- df %>% \n  group_by(trj_id) %>% \n  arrange(pingtimestamp) %>% \n  filter(row_number()==1) %>% \n  mutate(weekday = wday(pingtimestamp, label=TRUE, abbr=TRUE),\n         start_hr = factor(hour(pingtimestamp)),\n         day = factor(mday(pingtimestamp)))\n```\n:::\n\n\n-   **group_by(trj_id):** the data frame is grouped based on the unique trip identifiers (trj_id).\n\n-   **arrange(pingtimestamp):** within each trip group, the rows are arranged in ascending order based on the timestamp. This sorts the data in chronological order for each trip.\n\n-   **filter(row_number()==1):** for each trip group, only the row with the first coordinate is retained. This captures the origin of each trip.\n\n-   **mutate function:** is used to create additional columns that provide contextual information about each trip's starting location.\n\n### 5.3 Converting to sf tibble data frame\n\nIn this section, we transform origin_df into an sf tibble data frame using the st_as_sf function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin_sf <- st_as_sf(origin_df, coords = c(\"rawlng\", \"rawlat\"), crs = 3414)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(origin_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 28,000\nColumns: 11\nGroups: trj_id [28,000]\n$ trj_id        <chr> \"70895\", \"21926\", \"47498\", \"41322\", \"18103\", \"64813\", \"8…\n$ driving_mode  <chr> \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", \"car\", …\n$ osname        <chr> \"android\", \"android\", \"ios\", \"android\", \"android\", \"ios\"…\n$ pingtimestamp <dttm> 2019-04-08 00:09:40, 2019-04-08 00:09:49, 2019-04-08 00…\n$ speed         <dbl> 6.799661, 10.812810, 18.307493, 18.670000, 14.072143, 19…\n$ bearing       <int> 41, 68, 307, 230, 155, 109, 213, 202, 179, 109, 312, 209…\n$ accuracy      <dbl> 4.000, 4.000, 8.000, 3.900, 4.000, 10.000, 10.000, 10.00…\n$ weekday       <ord> Mon, Mon, Mon, Mon, Mon, Mon, Mon, Mon, Mon, Mon, Mon, M…\n$ start_hr      <fct> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ day           <fct> 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,…\n$ geometry      <POINT [m]> POINT (103.7709 1.380403), POINT (103.8627 1.29129…\n```\n:::\n:::\n\n\n::: callout-note\nNotice that a new geometry column has appeared.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry(origin_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 28000 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 103.6146 ymin: 1.244185 xmax: 104.0296 ymax: 1.465609\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n```\n:::\n:::\n\n\n## **6. Data Wrangling**\n\n### 6.1 Dropping Z dimensions\n\nBased on the information in previous sections, we can see that among the three data frames, origin_sf possesses the M dimension. To address this, we will utilize the st_zm() function, which is used to remove Z and/or M dimensions from feature geometries, resetting classes appropriately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin_sf <- st_zm(origin_sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_geometry(origin_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGeometry set for 28000 features \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 103.6146 ymin: 1.244185 xmax: 104.0296 ymax: 1.465609\nProjected CRS: SVY21 / Singapore TM\nFirst 5 geometries:\n```\n:::\n:::\n\n\n### 6.2 Handle invalid geometries\n\nNext, we check for invalid geometries and handle them accordingly.\n\n::: panel-tabset\n## Grab-Posisi\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(st_is_valid(origin_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## Road Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(st_is_valid(road_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n\n## MPSZ Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n\nAs shown above, the MPSZ data has 6 invalid geometries. To address this we use the ***st_make_valid*** function. This will result in the invalid geometries being removed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_make_valid(mpsz_sf)\nlength(which(st_is_valid(mpsz_sf) == FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n:::\n\n:::\n\n### 6.3 Projection system transformation\n\nAll spatial data must be projected into EPSG:3414, which is a projected coordinate system specific to Singapore. Now, we verify whether the current projected CRS of the data is correct and if necessary, transform them.\n\n::: panel-tabset\n## Grab-Posisi\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(origin_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n:::\n:::\n\n\n## Road Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(road_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n```\n:::\n:::\n\n\nThe data is not in EPSG:3414, therefore, we do a transformation to assign it the right code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroad_sf <- st_set_crs(road_sf, 3414)\nst_crs(road_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n:::\n:::\n\n\n## MPSZ Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(mpsz_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: WGS 84 \n  wkt:\nGEOGCRS[\"WGS 84\",\n    DATUM[\"World Geodetic System 1984\",\n        ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n            LENGTHUNIT[\"metre\",1]]],\n    PRIMEM[\"Greenwich\",0,\n        ANGLEUNIT[\"degree\",0.0174532925199433]],\n    CS[ellipsoidal,2],\n        AXIS[\"latitude\",north,\n            ORDER[1],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        AXIS[\"longitude\",east,\n            ORDER[2],\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n    ID[\"EPSG\",4326]]\n```\n:::\n:::\n\n\nThe data is not in EPSG:3414, therefore, we do a transformation to assign it the right code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_sf <- st_set_crs(mpsz_sf, 3414)\nst_crs(mpsz_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCoordinate Reference System:\n  User input: EPSG:3414 \n  wkt:\nPROJCRS[\"SVY21 / Singapore TM\",\n    BASEGEOGCRS[\"SVY21\",\n        DATUM[\"SVY21\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4757]],\n    CONVERSION[\"Singapore Transverse Mercator\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",1.36666666666667,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",103.833333333333,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",1,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",28001.642,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",38744.572,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"northing (N)\",north,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"easting (E)\",east,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Cadastre, engineering survey, topographic mapping.\"],\n        AREA[\"Singapore - onshore and offshore.\"],\n        BBOX[1.13,103.59,1.47,104.07]],\n    ID[\"EPSG\",3414]]\n```\n:::\n:::\n\n:::\n\n### 6.4 Preparing Singapore boundary layer\n\nThe MPSZ data includes subzone boundaries, however our needs are confined to Singapore's general boundary. To do this, we will use the st_union function, which consolidates or combines geometric features into a single geometry, resulting in the combined border of all subzones in the dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_sf <- mpsz_sf %>%\n  st_union() \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(sg_sf, main = \"Singapore Boundary Layer\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n### 6.5 Preparing Singapore road layer\n\nFor this study, we are also required to extract the road layer specific to Singapore. This can be done with the st_intersection function. This function identifies and retains the spatial intersections between geometries, allowing us to isolate the road segments that fall within the boundaries of Singapore.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroadSG_sf <- st_intersection(road_sf, sg_sf)\n```\n:::\n\n\n### 6.6 Mapping geospatial data sets with tmap\n\nLet us visualize our data!\n\n::: panel-tabset\n## Origins\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf) + \n  tm_polygons(col = \"#F0E1D7\", alpha = 0.5) + \n  tm_shape(origin_sf) +\n  tm_dots(size = 0.01, col = \"#2B2B2B\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n## Road Network\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(origin_sf) + \n  tm_dots(size = 0.05, col = \"#2B2B2B\") + \n  tm_shape(roadSG_sf) +\n  tm_lines(lwd = 0.5, col = \"#BF8D7A\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n:::\n\n## **7. Preparation before Deriving Kernel Density Estimation**\n\n### 7.1 Creating ppp objects\n\nTo use the functionalities provided by the spatstat package, our spatial data needs to be in the form of a point pattern object (ppp). In this section, we will transform our spatial data, which is currently stored as sf tibble data frames, into ppp objects using the as.ppp() function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\norigin_ppp <- as.ppp(origin_sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(origin_ppp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMarked planar point pattern:  28000 points\nAverage intensity 304722.2 points per square unit\n\nCoordinates are given to 6 decimal places\n\nmarks are of type 'character'\nSummary:\n   Length     Class      Mode \n    28000 character character \n\nWindow: rectangle = [103.61463, 104.02961] x [1.2441846, 1.4656086] units\n                    (0.415 x 0.2214 units)\nWindow area = 0.091887 square units\n```\n:::\n:::\n\n\nNow, we plot origin_ppp.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(origin_ppp)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n\n### 7.2 Handling duplicated points\n\nWe check for any duplication in a ppp object using the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nany(duplicated(origin_ppp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThe result is false, which indicates that there are no duplicated points in origin_ppp. Therefore, jittering, which is used to address overlapping points, will not be necessary in this context.\n\n### 7.3 Creating an owin object\n\nWhen analysing spatial point patterns, it is best to confine the analysis within a specific geographical area such as the Singapore boundary. In spatstat, an owin object is uniquely designed to represent this polygonal region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsg_owin <- as.owin(sg_sf)\n```\n:::\n\n\nNow, we plot and display the summary statistics of the output generated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(sg_owin)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(sg_owin)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWindow: polygonal boundary\n82 separate polygons (36 holes)\n                  vertices         area relative.area\npolygon 1            15251  5.69516e-02      8.93e-01\npolygon 2              285  1.30942e-04      2.05e-03\npolygon 3              719  4.39121e-03      6.89e-02\npolygon 4               44  1.84131e-07      2.89e-06\npolygon 5               27  1.22150e-06      1.92e-05\npolygon 6              706  1.04681e-03      1.64e-02\npolygon 7 (hole)        41 -3.26409e-06     -5.12e-05\npolygon 8 (hole)       316 -4.15500e-06     -6.52e-05\npolygon 9               77  2.68124e-05      4.20e-04\npolygon 10 (hole)        3 -8.52651e-21     -1.34e-19\npolygon 11 (hole)        3 -1.45500e-12     -2.28e-11\npolygon 12              30  2.27540e-06      3.57e-05\npolygon 13 (hole)        4 -2.03800e-11     -3.20e-10\npolygon 14 (hole)        3 -6.93000e-12     -1.09e-10\npolygon 15 (hole)        3 -2.55000e-12     -4.00e-11\npolygon 16 (hole)        3 -2.87500e-12     -4.51e-11\npolygon 17 (hole)        3 -1.04850e-11     -1.64e-10\npolygon 18 (hole)        3 -4.55924e-12     -7.15e-11\npolygon 19 (hole)        4 -3.53400e-11     -5.54e-10\npolygon 20 (hole)        5 -1.16350e-11     -1.82e-10\npolygon 21              71  6.65312e-07      1.04e-05\npolygon 22 (hole)        4 -5.20482e-11     -8.16e-10\npolygon 23 (hole)        3 -7.60480e-12     -1.19e-10\npolygon 24 (hole)       38 -6.33758e-07     -9.94e-06\npolygon 25 (hole)        3 -3.10000e-13     -4.86e-12\npolygon 26 (hole)        3 -3.96000e-12     -6.21e-11\npolygon 27              91  1.21616e-06      1.91e-05\npolygon 28 (hole)        3 -3.46000e-12     -5.43e-11\npolygon 29 (hole)        4 -2.82233e-12     -4.43e-11\npolygon 30               3  1.59650e-11      2.50e-10\npolygon 31 (hole)        3 -1.46879e-12     -2.30e-11\npolygon 32 (hole)      269 -9.86218e-08     -1.55e-06\npolygon 33 (hole)       19 -3.55700e-10     -5.58e-09\npolygon 34 (hole)       34 -1.12488e-08     -1.76e-07\npolygon 35 (hole)       23 -1.62267e-09     -2.54e-08\npolygon 36              40  1.12629e-06      1.77e-05\npolygon 37 (hole)       39 -4.87830e-07     -7.65e-06\npolygon 38 (hole)       11 -6.79831e-09     -1.07e-07\npolygon 39 (hole)        3 -3.00000e-13     -4.70e-12\npolygon 40              45  2.04147e-07      3.20e-06\npolygon 41             137  2.61888e-07      4.11e-06\npolygon 42             147  2.52227e-07      3.96e-06\npolygon 43 (hole)        4 -2.00000e-14     -3.14e-13\npolygon 44              75  1.41006e-06      2.21e-05\npolygon 45              83  4.29803e-07      6.74e-06\npolygon 46             211  3.82343e-05      6.00e-04\npolygon 47             106  2.47135e-07      3.88e-06\npolygon 48             264  1.22401e-04      1.92e-03\npolygon 49              71  4.57530e-07      7.17e-06\npolygon 50              10  1.62322e-08      2.55e-07\npolygon 51 (hole)        3 -2.22000e-12     -3.48e-11\npolygon 52             482  1.67489e-04      2.63e-03\npolygon 53             155  2.17371e-05      3.41e-04\npolygon 54            1020  1.03834e-04      1.63e-03\npolygon 55 (hole)        5 -4.21200e-11     -6.60e-10\npolygon 56 (hole)        4 -5.84300e-11     -9.16e-10\npolygon 57 (hole)        3 -2.06000e-12     -3.23e-11\npolygon 58 (hole)        4 -6.14500e-12     -9.64e-11\npolygon 59 (hole)        4 -1.00000e-14     -1.57e-13\npolygon 60              65  6.84899e-06      1.07e-04\npolygon 61 (hole)        3 -8.64000e-12     -1.35e-10\npolygon 62              47  3.10481e-06      4.87e-05\npolygon 63               6  3.65971e-08      5.74e-07\npolygon 64             129  7.75016e-06      1.22e-04\npolygon 65               4  2.18917e-08      3.43e-07\npolygon 66            1045  3.61201e-04      5.66e-03\npolygon 67              22  5.48185e-07      8.60e-06\npolygon 68              59  2.78850e-06      4.37e-05\npolygon 69              14  4.76604e-07      7.47e-06\npolygon 70              94  4.84443e-06      7.60e-05\npolygon 71             234  1.69631e-04      2.66e-03\npolygon 72              10  3.98977e-08      6.26e-07\npolygon 73             232  3.84260e-05      6.03e-04\npolygon 74 (hole)       13 -3.18647e-08     -5.00e-07\npolygon 75              15  3.27704e-06      5.14e-05\npolygon 76             227  8.96336e-05      1.41e-03\npolygon 77              10  5.36464e-07      8.41e-06\npolygon 78              19  2.51264e-06      3.94e-05\npolygon 79             145  7.81518e-05      1.23e-03\npolygon 80              30  3.48554e-07      5.47e-06\npolygon 81              37  1.05220e-06      1.65e-05\npolygon 82               4  7.69607e-09      1.21e-07\nenclosing rectangle: [103.6057, 104.08848] x [1.1586987, 1.4707748] units\n                     (0.4828 x 0.3121 units)\nWindow area = 0.0637736 square units\nFraction of frame area: 0.423\n```\n:::\n:::\n\n\n### 7.4 Combining point events object and owin object\n\nThis is the last step before deriving kernel density estimation. In this section, we extract Grab origin points that are located within Singapore by using the code below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noriginSG_ppp = origin_ppp[sg_owin]\nsummary(originSG_ppp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMarked planar point pattern:  28000 points\nAverage intensity 439053.1 points per square unit\n\nCoordinates are given to 6 decimal places\n\nmarks are of type 'character'\nSummary:\n   Length     Class      Mode \n    28000 character character \n\nWindow: polygonal boundary\n82 separate polygons (36 holes)\n                  vertices         area relative.area\npolygon 1            15251  5.69516e-02      8.93e-01\npolygon 2              285  1.30942e-04      2.05e-03\npolygon 3              719  4.39121e-03      6.89e-02\npolygon 4               44  1.84131e-07      2.89e-06\npolygon 5               27  1.22150e-06      1.92e-05\npolygon 6              706  1.04681e-03      1.64e-02\npolygon 7 (hole)        41 -3.26409e-06     -5.12e-05\npolygon 8 (hole)       316 -4.15500e-06     -6.52e-05\npolygon 9               77  2.68124e-05      4.20e-04\npolygon 10 (hole)        3 -8.52651e-21     -1.34e-19\npolygon 11 (hole)        3 -1.45500e-12     -2.28e-11\npolygon 12              30  2.27540e-06      3.57e-05\npolygon 13 (hole)        4 -2.03800e-11     -3.20e-10\npolygon 14 (hole)        3 -6.93000e-12     -1.09e-10\npolygon 15 (hole)        3 -2.55000e-12     -4.00e-11\npolygon 16 (hole)        3 -2.87500e-12     -4.51e-11\npolygon 17 (hole)        3 -1.04850e-11     -1.64e-10\npolygon 18 (hole)        3 -4.55924e-12     -7.15e-11\npolygon 19 (hole)        4 -3.53400e-11     -5.54e-10\npolygon 20 (hole)        5 -1.16350e-11     -1.82e-10\npolygon 21              71  6.65312e-07      1.04e-05\npolygon 22 (hole)        4 -5.20482e-11     -8.16e-10\npolygon 23 (hole)        3 -7.60480e-12     -1.19e-10\npolygon 24 (hole)       38 -6.33758e-07     -9.94e-06\npolygon 25 (hole)        3 -3.10000e-13     -4.86e-12\npolygon 26 (hole)        3 -3.96000e-12     -6.21e-11\npolygon 27              91  1.21616e-06      1.91e-05\npolygon 28 (hole)        3 -3.46000e-12     -5.43e-11\npolygon 29 (hole)        4 -2.82233e-12     -4.43e-11\npolygon 30               3  1.59650e-11      2.50e-10\npolygon 31 (hole)        3 -1.46879e-12     -2.30e-11\npolygon 32 (hole)      269 -9.86218e-08     -1.55e-06\npolygon 33 (hole)       19 -3.55700e-10     -5.58e-09\npolygon 34 (hole)       34 -1.12488e-08     -1.76e-07\npolygon 35 (hole)       23 -1.62267e-09     -2.54e-08\npolygon 36              40  1.12629e-06      1.77e-05\npolygon 37 (hole)       39 -4.87830e-07     -7.65e-06\npolygon 38 (hole)       11 -6.79831e-09     -1.07e-07\npolygon 39 (hole)        3 -3.00000e-13     -4.70e-12\npolygon 40              45  2.04147e-07      3.20e-06\npolygon 41             137  2.61888e-07      4.11e-06\npolygon 42             147  2.52227e-07      3.96e-06\npolygon 43 (hole)        4 -2.00000e-14     -3.14e-13\npolygon 44              75  1.41006e-06      2.21e-05\npolygon 45              83  4.29803e-07      6.74e-06\npolygon 46             211  3.82343e-05      6.00e-04\npolygon 47             106  2.47135e-07      3.88e-06\npolygon 48             264  1.22401e-04      1.92e-03\npolygon 49              71  4.57530e-07      7.17e-06\npolygon 50              10  1.62322e-08      2.55e-07\npolygon 51 (hole)        3 -2.22000e-12     -3.48e-11\npolygon 52             482  1.67489e-04      2.63e-03\npolygon 53             155  2.17371e-05      3.41e-04\npolygon 54            1020  1.03834e-04      1.63e-03\npolygon 55 (hole)        5 -4.21200e-11     -6.60e-10\npolygon 56 (hole)        4 -5.84300e-11     -9.16e-10\npolygon 57 (hole)        3 -2.06000e-12     -3.23e-11\npolygon 58 (hole)        4 -6.14500e-12     -9.64e-11\npolygon 59 (hole)        4 -1.00000e-14     -1.57e-13\npolygon 60              65  6.84899e-06      1.07e-04\npolygon 61 (hole)        3 -8.64000e-12     -1.35e-10\npolygon 62              47  3.10481e-06      4.87e-05\npolygon 63               6  3.65971e-08      5.74e-07\npolygon 64             129  7.75016e-06      1.22e-04\npolygon 65               4  2.18917e-08      3.43e-07\npolygon 66            1045  3.61201e-04      5.66e-03\npolygon 67              22  5.48185e-07      8.60e-06\npolygon 68              59  2.78850e-06      4.37e-05\npolygon 69              14  4.76604e-07      7.47e-06\npolygon 70              94  4.84443e-06      7.60e-05\npolygon 71             234  1.69631e-04      2.66e-03\npolygon 72              10  3.98977e-08      6.26e-07\npolygon 73             232  3.84260e-05      6.03e-04\npolygon 74 (hole)       13 -3.18647e-08     -5.00e-07\npolygon 75              15  3.27704e-06      5.14e-05\npolygon 76             227  8.96336e-05      1.41e-03\npolygon 77              10  5.36464e-07      8.41e-06\npolygon 78              19  2.51264e-06      3.94e-05\npolygon 79             145  7.81518e-05      1.23e-03\npolygon 80              30  3.48554e-07      5.47e-06\npolygon 81              37  1.05220e-06      1.65e-05\npolygon 82               4  7.69607e-09      1.21e-07\nenclosing rectangle: [103.6057, 104.08848] x [1.1586987, 1.4707748] units\n                     (0.4828 x 0.3121 units)\nWindow area = 0.0637736 square units\nFraction of frame area: 0.423\n```\n:::\n:::\n\n\nHere is the visualization of the resulting output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(originSG_ppp)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-39-1.png){width=672}\n:::\n:::\n\n\n## **9. Deriving Kernel Density Estimation**\n\n### 9.1 Rescaling data from meter to kilometer\n\nThe spatial data is in the SVY21 projection, and the unit of measurement for SVY21 is meters. Therefore, it is important to convert the unit of measurement to kilometers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noriginSG_ppp.km <- rescale(originSG_ppp, 1000, \"km\")\n```\n:::\n\n\n### 9.2 Choosing bandwidth & plotting map\n\nOnline sources recommend using the bw.ppl() algorithm for spatial patterns characterized by tight clusters, as it tends to produce more suitable values. However, they emphasize that if the goal is to identify a single tight cluster amid random noise, then the bw.diggle() method would likely be more effective. There are also methods such as bw.scott() and bw.CvL(). Let us compare these bandwidths with our previous tmap visualization.\n\n::: panel-tabset\n## bw.diggle\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(density(originSG_ppp.km,\n             sigma=bw.diggle,\n             edge=TRUE,\n             kernel=\"gaussian\"))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n## bw.ppl\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(density(originSG_ppp.km,\n             sigma=bw.ppl,\n             edge=TRUE,\n             kernel=\"gaussian\"))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n## bw.scott\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(density(originSG_ppp.km,\n             sigma=bw.scott,\n             edge=TRUE,\n             kernel=\"gaussian\"))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-43-1.png){width=672}\n:::\n:::\n\n\n## bw.CvL\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(density(originSG_ppp.km,\n             sigma=bw.CvL,\n             edge=TRUE,\n             kernel=\"gaussian\"))\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\n## Origins\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(mpsz_sf) + \n  tm_polygons(col = \"#F0E1D7\", alpha = 0.5) + \n  tm_shape(origin_sf) +\n  tm_dots(size = 0.01, col = \"#2B2B2B\")\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n:::\n\nThe visual analysis of the maps reveals that both bw.scott() and bw.CvL() result in more oversmoothed representations. This is evident in the overly spread gradient with bw.scott() and the merging of high-density regions into a uniform surface with bw.CvL(), making spatial patterns less apparent.\n\nOn the other hand, the maps generated with bw.diggle() and bw.ppl() show distinct differences. The bw.ppl() map appears to be more accurate, showcasing well-defined clusters that highlight concentrated areas, much like the spatial distribution observed in the tmap of Grab origin points.\n\nFor the final kernel density estimation map, the bandwidth method bw.ppl() will be used with the default Gaussian kernel method.\n\nFinal:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrab_kde <- density(originSG_ppp.km,\n             sigma=bw.ppl,\n             edge=TRUE,\n             kernel=\"gaussian\")\n\nplot(grab_kde)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n### 9.3 Kernel density estimation maps on OpenStreetMap\n\nIn this section, we will plot our kernel density estimation maps on OpenStreetMap. To achieve this, we must first convert the kernel density estimation maps into raster objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngridded_grab_kde <- as.SpatialGridDataFrame.im(grab_kde)\n\nraster_grab_kde <- raster(gridded_grab_kde)\n```\n:::\n\n\nNow, let's take a look at this raster object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraster_grab_kde\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 128, 128, 16384  (nrow, ncol, ncell)\nresolution : 3.771738e-06, 2.438095e-06  (x, y)\nextent     : 0.1036057, 0.1040885, 0.001158699, 0.001470775  (xmin, xmax, ymin, ymax)\ncrs        : NA \nsource     : memory\nnames      : v \nvalues     : -0.001192336, 1.0445e+13  (min, max)\n```\n:::\n:::\n\n\nAs shown above, the CRS of the raster object is NA. This means that it has to be assigned a projection system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojection(raster_grab_kde) <- CRS(\"+init=EPSG:3414 +units=km\")\nraster_grab_kde\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterLayer \ndimensions : 128, 128, 16384  (nrow, ncol, ncell)\nresolution : 3.771738e-06, 2.438095e-06  (x, y)\nextent     : 0.1036057, 0.1040885, 0.001158699, 0.001470775  (xmin, xmax, ymin, ymax)\ncrs        : +proj=tmerc +lat_0=1.36666666666667 +lon_0=103.833333333333 +k=1 +x_0=28001.642 +y_0=38744.572 +ellps=WGS84 +units=km +no_defs \nsource     : memory\nnames      : v \nvalues     : -0.001192336, 1.0445e+13  (min, max)\n```\n:::\n:::\n\n\nHere is the kernel density estimation maps on OpenStreetMap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_basemap(\"OpenStreetMap\") +\ntm_shape(raster_grab_kde) +\n  tm_raster(\"v\", palette = \"PuRd\", alpha=0.65) + \n  tm_layout(legend.position = c(\"right\", \"bottom\"), \n            main.title = \"Grab Origin Points Density Map\",\n            main.title.position = 'center',\n            main.title.size = 1,\n            frame = FALSE)\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\n### 9.4 Analysis of kernel density estimation maps\n\nBased on the kernel density maps above, we observe a number of clusters, two of which are more notable – one concentrated in the east and another larger cluster in the central region. Below is a map showing the regions in Singapore, and our observation matches the map.\n\n![](/data/Singapore-District-Map.jpg){fig-align=\"center\"}\n\n**East Region Concentration:** The unique concentration noticed in Singapore's eastern region can be attributed to the fact that it is close to Changi Airport. Changi Airport, as a major international hub, has a high volume of traffic, including both locals and visitors. The kernel density map could be reflecting the increased human mobility as they employ Grab services to go to and from the airport.\n\n**Central Business District (CBD) Cluster:** Moving towards the central region, we see a larger cluster, primarily in the Central Business District (CBD). This concentration is to be expected given that the CBD is Singapore's financial and commercial core. The daily influx of people commuting to and from work in this area adds to the high human mobility.\n\n**West and North Region Concentration:** Unlike the more concentrated clusters found in the east and the central business area, the west and north regions have smaller clusters that appear to be slightly more dispersed from one another. The observed dispersion could be explained by the residential landscape of both regions. The presence of numerous residential areas, industrial zones, and educational institutions affects human mobility as these are common areas that people go to.\n\n## **10. Deriving Network Constrained Kernel Density Estimation**\n\nNetwork constrained kernel density estimation is designed specifically for analyzing spatial point events that occur on or alongside a network.\n\nBased on previous analysis, where the two clusters of primary interest were Singapore's east and central regions, we will concentrate and examine these areas in greater depth with the use of network restricted kernel density estimation. This technique will enable us to incorporate the underlying network structure, such as roads and transportation links, in order to further understand the spatial distribution of events inside these clusters.\n\n### Preparing the road layer and origin points\n\n::: panel-tabset\n## Central Region\n\n\\~ Road Layer \\~\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncentral_region = mpsz_sf[mpsz_sf$REGION_N=='CENTRAL REGION',]\nroads_in_central = st_intersection(roadSG_sf, central_region)\n```\n:::\n\n\n\\~ Origin Points \\~\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints_in_central = st_intersection(origin_sf, central_region)\n```\n:::\n\n\n## East Region\n\n\\~ Road Layer \\~\n\n\n::: {.cell}\n\n```{.r .cell-code}\neast_region = mpsz_sf[mpsz_sf$REGION_N=='EAST REGION',]\nroads_in_east = st_intersection(roadSG_sf, east_region)\n```\n:::\n\n\n\\~ Origin Points \\~\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints_in_east = st_intersection(origin_sf, east_region)\n```\n:::\n\n:::\n\n### Visualizing geospatial data\n\n::: panel-tabset\n## Central Region\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(points_in_central) + \n  tm_dots() + \n  tm_shape(roads_in_central) +\n  tm_lines()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\n## East Region\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode('plot')\ntm_shape(points_in_east) + \n  tm_dots() + \n  tm_shape(roads_in_east) +\n  tm_lines()\n```\n\n::: {.cell-output-display}\n![](Take-home_Ex01_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n\n:::\n\n### Preparing the lixels objects\n\nBefore computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#lixels <- lixelize_lines(roadSG_sf, \n#                         750, \n#                         mindist = 375)\n```\n:::\n\n\n### Generating line centre points\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#samples <- lines_center(lixels)\n```\n:::\n\n\n## **12. References**\n\n-   Take-home Exercise 1: Geographic Analysis of the Supply and Demand of Childcare Services in Singapore by Xiao Rong Wong.\n\n-   Take-Home Exercise 2: Spatial Point Patterns Analysis of Airbnb Listings in Singapore by MEGAN SIM TZE YEN.\n\n-   Take-Home Exercise 1: Application of Spatial Point Pattern Analysis on Osun State, Nigeria by Michelle Leong Hwee-Ling.\n\n-   Hands-on Exercise 3\n\n-   In-class Exercise 2 and 3\n\n-   R for Geospatial Data Science and Analytics\n\n-   ChatGPT\n",
    "supporting": [
      "Take-home_Ex01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}