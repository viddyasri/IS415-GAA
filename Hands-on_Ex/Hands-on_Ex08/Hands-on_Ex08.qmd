---
title: "Hands-on Exercise 8"
execute: 
  warning: false
date: "`r Sys.Date()`"
highlight-style: dracula
---

## **1. Overview - Geographically Weighted Predictive Models**

Predictive modelling uses statistical learning or machine learning techniques to predict outcomes. By and large, the event one wants to predict is in the future. However, a set of known outcome and predictors (also known as variables) will be used to calibrate the predictive models.

Geospatial predictive modeling utilizes spatial data to forecast events by recognizing that these events are not randomly distributed across space but are influenced by various geographic factors like infrastructure, sociocultural elements, and topography. By analyzing historical geospatial data and correlating it with environmental factors, geospatial predictive modeling aims to understand and describe the constraints and influences shaping the occurrence of events in specific locations.

## **2. The Data**

-   **Aspatial dataset**: HDB resale data: a list of HDB resale transacted prices in Singapore from Jan 2017 onwards in csv format.

-   **Geospatial dataset**: *MP14_SUBZONE_WEB_PL*: a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data in ESRI shapefile format.

-   **Locational factors with geographic coordinates:**

    -   **Eldercare**: a list of eldercare in Singapore in shapefile format.

    -   **Hawker Centre**: a list of hawker centres in Singapore in geojson format.

    -   **Parks**: a list of parks in Singapore in geojson format.

    -   **Supermarket**: a list of supermarkets in Singapore in geojson format.

    -   **CHAS clinics:** a list of CHAS clinics in Singapore in geojson format.

    -   **Childcare service:** a list of childcare services in Singapore in geojson format.

    -   **Kindergartens**: a list of kindergartens in Singapore in geojson format.

    -   **MRT** data: a list of MRT/LRT stations in Singapore with the station names and codes in shapefile format.

    -   **Bus stops**: a list of bus stops in Singapore in shapefile format.

-   **Locational factors without geographic coordinates**:

    -   **Primary school** data extracted from the list on general information of schools in csv format

    -   **CBD** coordinates obtained from Google.

    -   **Shopping malls**: a list of Shopping malls in Singapore obtained from [Wikipedia](https://en.wikipedia.org/wiki/List_of_shopping_malls_in_Singapore).

    -   **Good primary schools**: a list of primary schools that are ordered in terms of popularity ranking.
    
## **3. Installing and Loading R packages**

```{r}
pacman::p_load(sf, spdep, GWmodel, SpatialML, 
               tmap, rsample, Metrics, tidyverse)
```

## **4. Preparing Data**

### Read rds file

```{r}
mdata <- read_rds("data/aspatial/mdata.rds")
```

### Data sampling

```{r}
set.seed(1234)
resale_split <- initial_split(mdata, 
                              prop = 6.5/10,)
train_data <- training(resale_split)
test_data <- testing(resale_split)
```

```{r}
write_rds(train_data, "data/model/train_data.rds")
write_rds(test_data, "data/model/test_data.rds")
```

## **5. Computing Correlation Matrix**

Before loading the predictors into a predictive model, it is always good practice to use a correlation matrix to examine if there are signs of multicolinearity.

```{r}
mdata_nogeo <- mdata %>%
  st_drop_geometry()
corrplot::corrplot(cor(mdata_nogeo[, 2:17]), 
                   diag = FALSE, 
                   order = "AOE",
                   tl.pos = "td", 
                   tl.cex = 0.5, 
                   method = "number", 
                   type = "upper")
```

::: callout-note
The correlation matrix above shows that all correlation values are below 0.8. Hence, there is no sign of multicolinearity.
:::

## **6. Building a Non-spatial Multiple Linear Regression**

```{r}
train_data <- readr::read_rds("data/model/train_data.rds")
test_data <- readr::read_rds("data/model/test_data.rds")
```

```{r}
price_mlr <- lm(resale_price ~ floor_area_sqm +
                  storey_order + remaining_lease_mths +
                  PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +
                  PROX_MRT + PROX_PARK + PROX_MALL + 
                  PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
                  WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +
                  WITHIN_1KM_PRISCH,
                data=train_data)
summary(price_mlr)
```

```{r}
write_rds(price_mlr, "data/model/price_mlr.rds" ) 
```

## **7. gwr Predictive Method**

### Converting the sf data.frame to SpatialPointDataFrame

```{r}
train_data_sp <- as_Spatial(train_data)
train_data_sp
```

### Computing adaptive bandwidth

bw.gwr() of the GWmodel package is used to determine the optimal bandwidth to be used.

```{r}
# commented out due to execution time
# bw_adaptive <- bw.gwr(resale_price ~ floor_area_sqm +
#                   storey_order + remaining_lease_mths +
#                   PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +
#                   PROX_MRT + PROX_PARK + PROX_MALL + 
#                   PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
#                   WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +
#                   WITHIN_1KM_PRISCH,
#                   data=train_data_sp,
#                   approach="CV",
#                   kernel="gaussian",
#                   adaptive=TRUE,
#                   longlat=FALSE)
```

::: callout-note
The code above is used to determine adaptive bandwidth and the CV method is used to determine the optimal bandwidth. The result shows that 40 neighbour points will be the optimal bandwidth if adaptive bandwidth is used for this data set.
:::

```{r}
#write_rds(bw_adaptive, "data/model/bw_adaptive.rds")
```

### Constructing the adaptive bandwidth gwr model

Now, we can go ahead and calibrate the gwr-based hedonic pricing model by using adaptive bandwidth and Gaussian kernel 

```{r}
bw_adaptive <- readr::read_rds("data/model/bw_adaptive.rds")
```

```{r}
gwr_adaptive <- gwr.basic(formula = resale_price ~
                            floor_area_sqm + storey_order +
                            remaining_lease_mths + PROX_CBD + 
                            PROX_ELDERLYCARE + PROX_HAWKER +
                            PROX_MRT + PROX_PARK + PROX_MALL + 
                            PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
                            WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +
                            WITHIN_1KM_PRISCH,
                          data=train_data_sp,
                          bw=bw_adaptive, 
                          kernel = 'gaussian', 
                          adaptive=TRUE,
                          longlat = FALSE)
```

```{r}
write_rds(gwr_adaptive, "data/model/gwr_adaptive.rds")
```

### Retrieve gwr output object

```{r}
gwr_adaptive <- read_rds("data/model/gwr_adaptive.rds")
```

```{r}
gwr_adaptive
```

### Converting the test data from sf data.frame to SpatialPointDataFrame

```{r}
test_data_sp <- test_data %>%
  as_Spatial()
test_data_sp
```

### Computing adaptive bandwidth for the test data

```{r}
# commented out due to execution time
# gwr_bw_test_adaptive <- bw.gwr(resale_price ~ floor_area_sqm +
#                   storey_order + remaining_lease_mths +
#                   PROX_CBD + PROX_ELDERLYCARE + PROX_HAWKER +
#                   PROX_MRT + PROX_PARK + PROX_MALL + 
#                   PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
#                   WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +
#                   WITHIN_1KM_PRISCH,
#                   data=test_data_sp,
#                   approach="CV",
#                   kernel="gaussian",
#                   adaptive=TRUE,
#                   longlat=FALSE)
```

### Computing predicted values of the test data

```{r}
# gwr_pred <- gwr.predict(formula = resale_price ~
#                           floor_area_sqm + storey_order +
#                           remaining_lease_mths + PROX_CBD +
#                           PROX_ELDERLYCARE + PROX_HAWKER +
#                           PROX_MRT + PROX_PARK + PROX_MALL +
#                           PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
#                           WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +
#                           WITHIN_1KM_PRISCH,
#                         data=train_data_sp,
#                         predictdata = test_data_sp,
#                         bw=40,
#                         kernel = 'gaussian',
#                         adaptive=TRUE,
#                         longlat = FALSE)

```

## **8. Preparing Coordinates Data**

### Extracting coordinates data

```{r}
coords <- st_coordinates(mdata)
coords_train <- st_coordinates(train_data)
coords_test <- st_coordinates(test_data)
```

```{r}
coords_train <- write_rds(coords_train, "data/model/coords_train.rds" )
coords_test <- write_rds(coords_test, "data/model/coords_test.rds" )
```

### Dropping geometry field

```{r}
train_data <- train_data %>% 
  st_drop_geometry()
```

## **9. Calibrating Random Forest Model**

In this section, we learn how to calibrate a model to predict HDB resale price by using the random forest function from the ranger package.

```{r}
set.seed(1234)
rf <- ranger(resale_price ~ floor_area_sqm + storey_order + 
               remaining_lease_mths + PROX_CBD + PROX_ELDERLYCARE + 
               PROX_HAWKER + PROX_MRT + PROX_PARK + PROX_MALL + 
               PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
               WITHIN_350M_CHILDCARE + WITHIN_350M_BUS + 
               WITHIN_1KM_PRISCH,
             data=train_data)
rf
```

```{r}
write_rds(rf, "data/model/rf.rds")
```

```{r}
rf <- read_rds("data/model/rf.rds")
rf
```

## **10. Calibrating Geographical Random Forest Model**

In this section, we calibrate another model to predict HDB resale price but this time using the grf() function from the SpatialML package.

### Calibrating with training data

```{r}
# commented out due to execution time
# set.seed(1234)
# gwRF_adaptive <- grf(formula = resale_price ~ floor_area_sqm + storey_order +
#                        remaining_lease_mths + PROX_CBD + PROX_ELDERLYCARE +
#                        PROX_HAWKER + PROX_MRT + PROX_PARK + PROX_MALL +
#                        PROX_SUPERMARKET + WITHIN_350M_KINDERGARTEN +
#                        WITHIN_350M_CHILDCARE + WITHIN_350M_BUS +
#                        WITHIN_1KM_PRISCH,
#                      dframe=train_data, 
#                      bw=55,
#                      kernel="adaptive",
#                      coords=coords_train)
```


```{r}
#write_rds(gwRF_adaptive, "data/model/gwRF_adaptive.rds")
```

```{r}
gwRF_adaptive <- read_rds("data/model/gwRF_adaptive.rds")
```

### Predicting with test data

Combine the test data with its corresponding coordinates data:

```{r}
test_data <- cbind(test_data, coords_test) %>%
  st_drop_geometry()
```

Predict resale value:

```{r}
# gwRF_pred <- predict.grf(gwRF_adaptive, 
#                            test_data, 
#                            x.var.name="X",
#                            y.var.name="Y", 
#                            local.w=1,
#                            global.w=0)
```

```{r}
#GRF_pred <- write_rds(gwRF_pred, "data/model/GRF_pred.rds")
```

### Converting the predicted output into a data frame

```{r}
GRF_pred <- readr::read_rds("data/model/GRF_pred.rds")
GRF_pred_df <- as.data.frame(GRF_pred)
```

Append the predicted values to test_data:

```{r}
test_data_p <- cbind(test_data, GRF_pred_df)
write_rds(test_data_p, "data/model/test_data_p.rds")
```

### Calculating root mean square error

The root mean square error (RMSE) allows us to measure how far predicted values are from observed values in a regression analysis.

```{r}
rmse(test_data_p$resale_price, 
     test_data_p$GRF_pred)
```

### Visualising the predicted values

```{r}
ggplot(data = test_data_p,
       aes(x = GRF_pred,
           y = resale_price)) +
  geom_point()
```

::: callout-note
The scatter plot can be also used to detect outliers in the model, if any.
:::