---
title: "Hands-on Exercise 3"
execute: 
  warning: false
date: "`r Sys.Date()`"
highlight-style: dracula
---

## **1. Overview**

#### Spatial Point Analysis

Spatial Point Pattern Analysis is the evaluation of the pattern or distribution, of a set of points on a surface. The point can be a location of events such as crime and traffic accident OR business services and facilities such as retail outlets and childcare.

In this exercise, we'll be using appropriate functions from spatstat ( a package in the R programming language designed for the analysis and modeling of spatial point patterns) to discover the spatial point processes of childcare centres in Singapore.

The questions we'd like to answer are:

-   are the childcare centres in Singapore randomly distributed throughout the country?

-   if the answer is not, then the next logical question is where are the locations with higher concentration of childcare centres?

## **2. The Data**

a.  CHILDCARE, a point feature data providing both location and attribute information of childcare centres.

b.  MP14_SUBZONE_WEB_PL, a polygon feature data providing information of URA 2014 Master Plan Planning Subzone boundary data.

c.  CostalOutline, a polygon feature data showing the national boundary of Singapore.

## **3. Installing and Loading the R packages**

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

## **4. Spatial Data Wrangling**

#### Importing the spatial data

::: callout-note
3414 : Projected coordinate system for Singapore
:::

```{r}
childcare_sf <- st_read("data/ChildCareServices.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "data", layer="CostalOutline")
```

```{r}
mpsz_sf <- st_read(dsn = "data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

**Before we can use these data for analysis, it is important for us to ensure that they are projected in same projection system.**

CHILDCARE:

```{r}
st_crs(childcare_sf)
```

```{r}
st_geometry(childcare_sf)
```

COASTAL OUTLINE:

```{r}
st_crs(sg_sf)
```

```{r}
st_geometry(sg_sf)
```

MP14_SUBZONE_WEB_PL:

```{r}
st_crs(mpsz_sf)
```

```{r}
st_geometry(mpsz_sf)
```

::: callout-note
Notice that except childcare_sf, both mpsz_sf and sg_sf do not have proper crs information.
:::

```{r}
mpsz_sf <- st_set_crs(mpsz_sf, 3414)
```

```{r}
sg_sf <- st_set_crs(sg_sf, 3414)
```

#### Mapping the geospatial data sets

```{r}
tmap_mode("plot")
tm_shape(mpsz_sf) +
  tm_polygons() +
  tm_shape(childcare_sf) +  
  tm_dots()
```

::: callout-note
Notice that all the geospatial layers are within the same map extend. This shows that their referencing system and coordinate values are referred to similar spatial context.
:::

Alternatively, we can also prepare a pin map by using the code below.

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot') #always switch back to plot from view
```

::: callout-note
The advantage of this interactive pin map is it allows us to navigate and zoom around the map freely.
:::

## **5. Geospatial Data Wrangling**

In this section, we will learn how to convert simple feature data frame to sp’s Spatial\* class.

#### Converting sf data frames to sp’s Spatial\* class

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

Display the information:

```{r}
summary(childcare)
```

```{r}
summary(mpsz)
```

```{r}
summary(sg)
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

#### Converting the Spatial\* class into generic sp format

spatstat requires the analytical data in ppp object form. There is no direct way to convert a Spatial\* classes into ppp object. We need to convert the Spatial classes\* into Spatial object first.

```{r}
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")

childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

```{r}
childcare_sp
```

```{r}
sg_sp
```

#### Converting the generic sp format into spatstat’s ppp format

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

```{r}
summary(childcare_ppp) #summary statistics
```

Now, we plot childcare_ppp:

```{r}
plot(childcare_ppp)
```

#### Handling duplicated points

We check duplication using the code below:

```{r}
any(duplicated(childcare_ppp))
```

To count the number of coincident points (points in a dataset share the exact same location or coordinates), we use this code:

```{r}
multiplicity(childcare_ppp)
```

If we want to know how many locations have more than one coincident point event, we can use the code below.

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

To view the locations of these duplicate point events, we will plot childcare data by using the code chunk below.

```{r}
tmap_mode("view")
tm_shape(childcare_sf) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode("plot")
```

There are three ways to overcome the duplication.

-   Delete the duplicates. But, that will also mean that some useful point events will be lost.

-   Jittering, which will add a small perturbation to the duplicate points so that they do not occupy the exact same space.

-   Make each point “unique” and then attach the duplicates of the points to the patterns as marks, as attributes of the points. Then you would need analytical techniques that take into account these marks.

The code below is an example of Jittering:

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

#### Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In spatstat, an object called owin is specially designed to represent this polygonal region.

```{r}
sg_owin <- as(sg_sp, "owin")
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

#### Combining point events object and owin object

In this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore by using the code below.

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
summary(childcareSG_ppp)
```

```{r}
plot(childcareSG_ppp)
```

## **6. 1st Order Spatial Point Patterns Analysis Methods**

This section will focus on:

-   deriving kernel density estimation (KDE) layer for visualising and exploring the intensity of point processes

-   performing Confirmatory Spatial Point Patterns Analysis by using Nearest Neighbour statistics.

#### Kernel Density Estimation

In this section, we will learn how to compute the kernel density estimation (KDE) of childcare services in Singapore.

##### Computing kernel density estimation using automatic bandwidth selection method

-   bw.diggle() automatic bandwidth selection method. Other recommended methods are bw.CvL(), bw.scott() or bw.ppl().

::: callout-note
***bw.CvL() - Cross-Validation Likelihood:***

What it does: Chooses bandwidth to maximize model performance using cross-validation. Use when: You want a bandwidth that works well on unseen data.

***bw.scott() - Scott's Rule:***

What it does: Uses a simple rule based on standard deviation and sample size. Use when: You prefer a quick and straightforward bandwidth estimate.

***bw.ppl() - Plug-in (Sheather-Jones):***

What it does: Estimates distribution parameters for bandwidth calculation. Use when: You want a bandwidth based on estimated distribution characteristics.
:::

-   The smoothing kernel used is gaussian, which is the default. Other smoothing methods are: “epanechnikov”, “quartic” or “disc”.

::: callout-note
Choose the "Epanechnikov" kernel for optimal mean integrated squared error and balanced performance.

Choose the "Quartic" kernel for a smoother estimate, accepting a bit more bias compared to Epanechnikov.

Choose the "Disc" kernel when you want equal contribution from all points within the kernel window, regardless of their distance.
:::

-   The intensity estimate is corrected for edge effect bias by using method described by Jones (1993) and Diggle (2010, equation 18.9). The default is FALSE.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

```{r}
plot(kde_childcareSG_bw) #to display the kernel density derived
```

::: callout-note
The density values of the output range from 0 to 0.000035 which is way too small to comprehend. This is because the default unit of measurement of svy21 is in meter. As a result, the density values computed is in “number of points per square meter”.
:::

```{r}
bw <- bw.diggle(childcareSG_ppp) #to retreieve bandwidth used to compute KDE
bw
```

##### Rescalling KDE values

```{r}
#convert meter to kilometer
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

```{r}
# re-run density() using the re-scaled data set and plot the output
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

##### Working with different automatic badwidth methods

First, we look at bandwidth:

```{r}
bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

::: callout-note
Baddeley et. (2016) suggested the use of the bw.ppl() algorithm because in ther experience it tends to produce the more appropriate values when the pattern consists predominantly of tight clusters. But they also insist that if the purpose of once study is to detect a single tight cluster in the midst of random noise then the bw.diggle() method seems to work best.
:::

Comparing the output of using bw.diggle and bw.ppl methods:

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

##### Working with different kernel methods

By default, the kernel method used in density.ppp() is gaussian. But there are three other options, namely: Epanechnikov, Quartic and Dics.

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

#### Fixed and Adaptive KDE

##### Computing KDE by using fixed bandwidth

Next, we will compute a KDE layer by defining a bandwidth of 600 meter (0.6km):

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

##### Computing KDE by using adaptive bandwidth

Fixed bandwidth method is very sensitive to highly skew distribution of spatial point patterns over geographical units for example urban versus rural. One way to overcome this problem is by using adaptive bandwidth instead.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

Comparing the two:

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

##### Converting KDE output into grid object.

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

**Converting gridded output into raster:**

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
kde_childcareSG_bw_raster
```

::: callout-note
Notice that the crs property is NA.
:::

**Assigning projection systems:**

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

##### Visualising the output in tmap

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

##### Comparing Spatial Point Patterns using KDE

**Extract the target planning areas:**

```{r}
#must be sp layer to do this
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

**Plotting target planning areas:**

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Punggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

**Converting the spatial point data frame into generic sp format:**

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

**Creating owin object:**

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

**Combining childcare points and the study area:**

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

**Change unit of measurement:**

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

**Plot:**

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

**Compute KDE:**

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

**Compute fixed bandwidth KDE:**

```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

#### Nearest Neighbour Analysis

The test hypotheses are:

Ho = The distribution of childcare services are randomly distributed.

H1= The distribution of childcare services are not randomly distributed.

The 95% confident interval will be used.

##### Testing spatial point patterns using Clark and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

##### Clark and Evans Test: Choa Chu Kang planning area

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

##### Clark and Evans Test: Tampines planning area

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

## **7. 2nd Order Spatial Point Patterns Analysis Methods**

#### Analysing Spatial Point Process Using G-Function

The G function measures the distribution of the distances from an arbitrary event to its nearest event.

##### Choa Chu Kang planning area

**Computing G-function estimation:**

```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

::: callout-note
Use the "border" correction when your point pattern data might be affected by edge effects, such as points located near the boundary of the study region.
:::

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

Monte Carlo test with G-fucntion

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

```{r}
plot(G_CK.csr)
```

##### Tampines planning area

**Computing G-function estimation:**

```{r}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

::: callout-note
Use the "best" correction when you want the function to automatically select the correction method based on the characteristics of your point pattern data.
:::

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected is p-value is smaller than alpha value of 0.001.

```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

```{r}
plot(G_tm.csr)
```

#### Analysing Spatial Point Process Using F-Function

The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape.

##### Choa Chu Kang planning area

**Computing F-function estimation:**

```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

```{r}
plot(F_CK.csr)
```

##### Tampines planning area

**Computing F-function estimation:**

```{r}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

```{r}
plot(F_tm.csr)
```

#### Analysing Spatial Point Process Using K-Function

K-function measures the number of events found up to a given distance of any particular event.

##### Choa Chu Kang planning area

**Computing K-function estimation:**

```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

##### Tampines planning area

**Computing K-function estimation:**

```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, 
     ylab= "K(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```

#### Analysing Spatial Point Process Using L-Function

##### Choa Chu Kang planning area

**Computing L-function estimation:**

```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Choa Chu Kang are randomly distributed.

H1= The distribution of childcare services at Choa Chu Kang are not randomly distributed.

The null hypothesis will be rejected if p-value if smaller than alpha value of 0.001.

```{r}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

##### Tampines planning area

**Computing L-function estimation:**

```{r}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

**Performing Complete Spatial Randomness Test:**

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of childcare services at Tampines are randomly distributed.

H1= The distribution of childcare services at Tampines are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001.

```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
